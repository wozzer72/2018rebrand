<!DOCTYPE HTML>
<!--
	Forty by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>microservices</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="apple-touch-icon" sizes="57x57" href="../favicon/apple-icon-57x57.png">
		<link rel="apple-touch-icon" sizes="60x60" href="../favicon/apple-icon-60x60.png">
		<link rel="apple-touch-icon" sizes="72x72" href="../favicon/apple-icon-72x72.png">
		<link rel="apple-touch-icon" sizes="76x76" href="../favicon/apple-icon-76x76.png">
		<link rel="apple-touch-icon" sizes="114x114" href="../favicon/apple-icon-114x114.png">
		<link rel="apple-touch-icon" sizes="120x120" href="../favicon/apple-icon-120x120.png">
		<link rel="apple-touch-icon" sizes="144x144" href="../favicon/apple-icon-144x144.png">
		<link rel="apple-touch-icon" sizes="152x152" href="../favicon/apple-icon-152x152.png">
		<link rel="apple-touch-icon" sizes="180x180" href="../favicon/apple-icon-180x180.png">
		<link rel="icon" type="image/png" sizes="192x192"  href="../favicon/android-icon-192x192.png">
		<link rel="icon" type="image/png" sizes="32x32" href="../favicon/favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="96x96" href="../favicon/favicon-96x96.png">
		<link rel="icon" type="image/png" sizes="16x16" href="../favicon/favicon-16x16.png">
		<link rel="manifest" href="../favicon/manifest.json">
		<meta name="msapplication-TileColor" content="#ffffff">
		<meta name="msapplication-TileImage" content="../favicon/ms-icon-144x144.png">
		<meta name="theme-color" content="#ffffff">
		<!--[if lte IE 8]><script src="../assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="../assets/css/main.css" />
		<!--[if lte IE 9]><link rel="stylesheet" href="../assets/css/ie9.css" /><![endif]-->
		<!--[if lte IE 8]><link rel="stylesheet" href="../assets/css/ie8.css" /><![endif]-->
	</head>
	<body>

		<!-- Wrapper -->
		<div id="wrapper">

			<!-- Header -->
			<!-- Note: The "styleN" class below should match that of the banner element. -->
			<header id="header" class="alt style2">
				<a href="../index.html" class="logo"><strong>WOZ</strong>iTech <span>Ltd</span></a>
				<nav>
					<a href="#menu">Menu</a>
				</nav>
			</header>

			<!-- Menu -->
			<nav id="menu">
				<ul class="links">
						<li><a href="../technologies.html">Technologies</a></li>
						<li><a href="tokenSecurity.html">Token API Security</a></li>
					</ul>
				<ul class="actions vertical">
					<li><a href="../index.html" class="button special fit">Home</a></li>
				</ul>
			</nav>

			<!-- Banner -->
			<!-- Note: The "styleN" class below should match that of the header element. -->
			<section id="banner" class="style2"  style="background-image: url('../images/microservices.png');background-size: 450px 450px;">
				<div class="inner">
					<header class="major">
						<h1>Microservices</h1>
					</header>
					<div class="content">
						Overview of Microservices
					</div>
				</div>
			</section>

			<div id="main">
				<section id="introduction">
						<div class="inner">
							<header>
								<h1>Introduction</h1>
							</header>
							<p>
								WOZiTech promotes the use of Microservices to break down complex applications into
								easily maintained, deployed and managed components, with use of best breed technologies for each
								service (or in the case of WOZiTech projects, demonstration of new technologies by a given service)
								with scale and security built-in.
							</p>
							<p>
								Microservices is an IT buzzword, but what are microservices? Let&apos;s demistify them here.
							</p>
						</div>
					</section>
		
				<section id="isolation">
					<div class="inner">
						<header class="major">
							<h2>Isolation</h2>
						</header>
						<h3>Runtime</h3>
						<p>
							First, and foremost, microservices are isolated from each other at runtime. A failure in one service
							does not impact on another service. This applies not just across different services but equally each
							instance of the same service. This latter isolation is where &quot;serverless functions&quot; come
							into their own. To isolate each instance of a service, if a system-level error occurs in a service instance then
							that service instance should be rejected and a new instance of that service started to backfill.
						</p>
						<h3>Deployment</h3>
						<p>
							Second, microservices are isolated from each other during deployment. A failure in one service deployment
							does not impact upon other services, during or after the deployment. More than just each service can be deployed
							independently, each service can be deployed to different targets/platforms.
						</p>
						<h3>Packaging</h3>
						<p>
							Third, microservices are isolated from each other through packaging. A change in one service does not impact
							upon other services. A change in one service which consequently requries deployment, does not require the
							re-deployment of other services.
							<br/><br/>
							Isolated packaging ensures the smallest scope of deployment and consequently, the smallest scope of change. Low
							level of changes encourages high levels of availability.
						</p>
						<p>
							Consider also service maturity; where the microservice is extended over time.

							Versioning of APIs are common practice; a typical node application uses npm
							to manage 3rd part libraries, all at specific versions within package.json. Every microservice should be
							versioned and every client should define the version of API to which they are subscribing to, even if that
							client declaration is "latest" (version).
							<br/><br/>
							A stable service is one that stable clients will depend upon. If having to make changes to a stable service
							consider first creating and deploying a new service with those chamges, thus isolating the existing stable service.
							Over time as this new service establises itself and itself becomes stable, consider then whether to
							merge it back to the original service (as a new verion of).
						</p>
						<h3>Data</h3>
						<p>
							And finally, it is well accepted that microservices should own their data in its entirety. Each microservice
							should have its own data store; that data store chosen specifically for the type of data it owns (or abstracts
							in the case of integrating services).
							<br/><br/>
							A caching microservice would benefit from fast storage, such as, redis/memcached. An analytics service would
							benefit from a warehouse style store.
							<br/><br/>
							By having its own store of data and owning that store, each microservice is able to apply its own optimisations
							for accessing that, safe that it does not impact other services.
						</p>
						<p>
							But there is a playoff on how much isolation can be supported and this vary across projects and services.
							<br/>
							<i>Need to explore this one way in respect of </i>
						</p>
					</div>
				</section>

				<section id="Security" class="spotlights">
					<div class="inner">
						<header class="major">
							<h2>Security Built-In</h2>
						</header>
						<p>
							Not specific to microservices per se, but a mandatory characteristic as seen by WOZiTech, is that all
							microservices should enforce security for all their APIs; even if that security is simply to "allow all".
						</p>
						<p>
							There are many different approches to authentication (identity) and authorisation (approval); we shall shorten this to simply <i>A&amp;A</i>.
							The fact that microservices are stateless implies A&amp;A must be performed on every call. For performance and isolation,
							it is not ideal for any microservices to have to rely on an exteral lookup for A&amp;A resolution.
						</p>
						<p>
							Token based A&amp;A is the recommended approach as the token assures identity (authentication) and contains all
							information necessary for approval (authorisation).
						</p>
						<ul class="actions vertical">
							<li><a href="tokenSecurity.html" class="button">Token Based Security</a></li>
						</ul>
					</div>
				</section>

				<section id="BestTechChoice" class="spotlights">
					<div class="inner">
						<header class="major">
							<h2>Best Choice of Technologies</h2>
						</header>
						<p>
							The IT industry is <i>blessed</i> with a multitude of technologies, each with their own evangelists and practioners.
							Some argue why there are so many different technologies and arguments have ensued whilst weighing up one
							technology over another with facts and passion. Some argue the birth of some technology is unnecessary. If you
							have one web server, why do you need another? If you have one computer language, why another? To counter
							the last argument, consider if you will a hardware store and the choice of screwdrivers available; surely, if you want just
							one screwdriver, why are their hundreds of screwdrivers to choice from?
						</p>
						<p>
							But projects struggle to cope with a multitude different technologies; often limitations have been knowingly imposed based on the choice
							of technology made at the start of a project/product. With multiple technologies you have issues on skills availability,
							deployment and integration, especially when creating large complex applications with production-level deployment.
							Service Oriented Architecture (SOA) came
							to solve the issue of heterogenous application environments by integrating disparate applications (components) with an
							Enterprise Service Bus (ESB) or Broker (centralised/federated integration). You could continue to invest in legacy
							monolithic applications, yet build new more efficient web interfaces with data analytics and user profiling services.
						</p>
						<p>
							But SOA is complex and requires highly skills architects and designers, and requires the deployment and support of
							a platform on which to run SOA with the integration of that SOA platform with service endpoints (new and legacy
							alike). It requires a team of highly skilled engineers to run just the SOA platform itself.
						</p>
						<p>
							With the rise of containers over the past years, fueled by kuberenetes and now
							capable approach of application deployment as containers, support for diverse technologies on consolidated platforms
							has never been easier. With a <i>docker image</i> you can quickly introduce services to your platform from both
							internal and external sources.
						</p>
						<p>Microservices have segued from traditional SOA and pure docker solutions by continuing
							to promote best choice of technology but simplifying implementation by adopting the ubiquitous web protocol.
							
							The traditional ESB with its plethora of adaptors to connect to new and legacy applications/data stores and its complexity?
							Gone. Every service is a simple web endpoint.
							<br/><br/>
							Database connectors (PostgreSQL, MySQL/MariaDB, SQLServer, DB2), messaging connectors (CICS, MQSeries, JMS),
							email (pop, imap, smtp). All gone.
							<br/><br/>
							Proprietary scaling and failover solutions. Gone. Replaced with well understood http load balancing.
							<br/><br/>
							Proprietary security solutions. Gone. Replaced with TLS (SSL) and their certificates.
						</p>
					</div>
				</section>

				<section id="Scaling">
					<div class="inner">
						<header class="major">
							<h2>Scaling</h2>
						</header>
						<p>
							Scaling is the ability to grow an application as demand is imposed on the application.
						</p>
						<p>Traditional methods were focused on vertical scaling (buy a bigger/faster box; physical or virtual).
							More dyanamic is horizontal scaling; two, three, four or more boxes (phyical or virtual). Horizontal scaling requires balancing
							load across each instance. Balancing algorithms like, round-robin, random, least-connection (used) and least-load (weighted response time)
							are used to spread incoming connections. Horizontal scaling has the added bonus of failover and resiliency.  But to benefit from
							horizontal scaling, your application needs to be aware. Moreso, you need to handle state across multiple instances; get 
							this wrong and any benefit of horizontal scaling is lost.
						</p>
						<p>
							With the introduction of cloud computing, moreso, public clouds, can adaptive load balancing; scale up yet also scale down, based
							on incoming demand. You then only pay for what you used. Large boundaries were placed on the increments/decrements owing to
							the time it took to start a virtualised server or stop. With Docker and containers, it got quicker to start and stop; scale up 
							and scale down became the norm. But it was still pretty much full application instances that were being scaled horizontally.
						</p>
						<p>
							With the prevelance of docker came kuberenetes; managed instances. It is now easy to provision 10 of those, 20 of them and 5 of these.
							What are &quot;those, them and these&quot;? They are instances of part of the application; 10 web servers, 20 app servers and 5 database servers.
							As demand increases, those 10 web servers and 20 app servers are scaled with different ratios depending on the applicaton resources
							consumed. But break the application into components. &quot;those, them and these&quot; now become 20 instances of order services,
							10 instances of payment servies and 5 instances of product cache. But not just three ratios to manage, you now have tens/hundreds of
							different ratios (application clusters) to scaling up and scaling down with different cadence based on application demand. This is can be
							visualised as a &apos;Murmuration of Starlings&apos;; a swarm of birds sweeping and turning in the sunset sky with individuals peeling
							off and joining at different times. But this being a set of containers not starlings, and the sky being a kubernetes cluster.
						</p>
						<p>
							Microservices is taking this approach to the extreme. Each microservice can be scaled up/down. The fine grained microservices
							being more functions than components. Moreso than before, the microservice must be packaged & deployed in a way to benefit from this
							scaling approach. The microservice needs to be packaged as a Docker template/image.
						</p>
						<p>
							Serverless microservices simply takes away any need to manage the provision of resources but it does restrict the technology that
							can be provisioned based on that made available by the cloud provider. Although note, AWS serverless functions (lambda) does support
							the notion of a docker image/template as the ultimate "get out clause".
						</p>
					</div>
				</section>

				<section id="Not">
					<div class="inner">
						<header class="major">
							<h2>Microservices Are Not ...</h2>
						</header>
						<p>
							As significant as it is in defining what microservices are, it is necessary to describe what they are not.
						
							Unlike SOA, microservices are fine grained (SOA tends to course grained services) and do not set about to encourage reuse.
							Microservices have no formal contract. There are no dependencies between microservices and no &quot;managed&quot;
							orchestration between microservices. Microservices depend on no specific runtime platform specific.
						</p>
						<h3>What do we mean by &quot;unmanaged orchestration&quot;?</h3>
						<p>
							We are not saying that microservices are not part of
							a larger business process, as typified of a service environment. But their involvement in such is directed by
							the consumer of the microservice. There is no underlying abstraction coordinating their involvement.
						</p>
						<h3>What do we mean by &quot;not platform specific&quot;?</h3>
						<p>
							The very essence of microservices is they leverage the
							ubiquitous web protocol. Even mainframes can support the web protocol. All modern platforms support the web protocol.
							There is no open source/community (e.g. mulesoft/fuse) or expensive commercial (IBM Message WebBroker, Tibco, Oracle)
							SOA platform. You can use different platforms in each of your environments. You can use platforms supported natively
							by cloud providers and within the same environment spread those microservices across multiple providers (providing
							resilience from that cloud provider). Because microservices are not constrained by any platform, your
							3rd party suppliers/agencies are free from any particular choice you have made.
							
							<br/><br/>
							Of course, if you already have a SOA platform, it can host microservices (all SOA platforms will support web protocol).
							For a SOA that is heavy on message, it is worth highlighting <a target="_blank" href="http://jmesnil.net/stomp-websocket/doc/">STOMP
							over WebSockets</a> can be used for a bidirectional messaging interface over http as a method of integrating SOA with microservices.

							<br/><br/>
							By not being dependent on any specific platform, not are are you free to choose, you are free to change! Make a choice and run with
							it. But if it&quot;s no longer working, then change your platform of choice. And yes, you are free to change your 3rd parties too.
						</p>
						<h3>What do we mean by &quot;not encouraging reuse&quot;?</h3>
						<p>
							With a SOA implementation, much time is invested upfront to decompose business domains into reusable set of services. Those services (components) are like mini-applications; where it makes sense to consolidate a particular business function,
							it is grouped within a service (component).
							
							<br/><br/>
							By name alone (micro), microservices should be small, function (not component) based services.
							It is not important if they are used in more than one place; what is important is that the function they perform has been isolated.
							As noted above, to protect service availability, if making a substantial change to an existing microservice you should
							be encouraged to create a new microservice.

							<br/><br/>
							But there is nothing wrong if indeed the microservice is (re)used in many different scenarios.
						</p>
						<h3>What do we mean by &quot;no formal contract&quot;?</h3>
						<p>
							To encourage interoperability between services in a SOA implementation, it is necessary to focus on the contract
							of the service. That contract being a description of what features that services provides. The contract
							is then registered allowing that service to become discoverable.

							Such a constract would be based on standardised contracts; remember the WS* standards (WS-Security, WS-Transer, WS-Addressing, ...).
							These contracts are verbose and complex covering a great number of use scenarios. Implementing a service conforming to such
							standards requires a lot of effort.

							<br/><br/>
							That is not to say that microservices do not have a contract. They have a service definition (typically
							RESTful style well-documented using swagger). But rather than based on some complex standard, the service
							definition (contract) is specific to the task (function) at hand. With evolutionary development of the
							microservice, this informal contract will change. That change should be via contract (interface specification
							versioning).
							
							The WOZiTech preferred approach is with <a target="_blank" href="https://www.baeldung.com/rest-versioning">Media Type</a> versioning.
							But be aware, when changing the Content-Type header, the client needs to be version aware and parse the
							content type appropriately. For example, in the linked example, &quot;Content-Type: application/vnd.myname.v2+json&quot;
							needs to be parsed (split on &apos;+&apos;) to resolve &quot;json&quot;. Web Browers (circa Oct2018) are
							not aware, and consequently, if using your web browser to test results, they will not formally recognise JSON content.
							
							<br/><br/>
							Because of this absence of formalised contract and abstraction orchestration, it is necessary that the
							consumer (client) is specific about version of microservice it uses but also then when testing, the
							"in use" contract is tested in isolation from the service logic (best tested with unit tests and mocking).
						</p>
						<h3>What do we mean by &quot;fine grained&quot;?</h3>
						<p>
							Microservices are constructed at function level whereas SOA is component level.
							A large application could have been composed of 10 or 20 SOA services, compared to 100 or 200 microservices.
							A component will have many functions, whereas a microservice has a single (maybe two/three) function.
							A microservice exhibits "high cohesion" (everything within the microservice is specifically related).
							<br/><br/>
							A great article around microservices testing from <a target="_blank" href="https://medium.com/@danielbryantuk/microservice-testing-coupling-and-cohesion-all-the-way-down-b84dacf8cff0">
								Daniel Bryant</a> describes the impact and consequence of coupling and cohesion, nicely summarised by the
								image below.
							<br/><br/>
							<div class="12u">
								<span class="image fit">
									<a target="_blank" href="https://cdn-images-1.medium.com/max/800/1*tCfa0GweDvl2k3wQ74A8iQ.png">
										<img class="opacity: 0.5; filter: alpha(opacity=50);"
											src="../images/daniel-bryant-medium.com-microservice-testing-coupling-and-cohesion-all-the-way-down.png"
											alt="Cohesion and Coupling diagram reproduced from https://medium.com/@danielbryantuk/microservice-testing-coupling-and-cohesion-all-the-way-down-b84dacf8cff0"/>
									</a>
								</span>
							</div>
						</p>
					</div>
				</section>

				<section id="Challenges">
					<div class="inner">
						<header class="major">
							<h2>Challenges</h2>
						</header>
						<p>
							Microservices are not the silver bullet; they are simply an architectural approach/style and as with any such approach
							they have limitations and deficiencies.
						</p>
						<h3>CI/CD</h3>
						<p>
							Function-level deployment implies that in any sizable project you will have many microservices and you can expect
							to change each many times over its lifetime. You will also want to get the changes into live operations as quick as you can.

							For that, you need a good <a href="https://semaphoreci.com/blog/2017/07/27/what-is-the-difference-between-continuous-integration-continuous-deployment-and-continuous-delivery.html">
							Continuous Integration, Continuous Deployment and Continuous Delivery</a> solution.

							As soon as code is committed, automated unit and integration tests are performed, automated builds and deployments
							into acceptance and regression tests environments and automated (ungated yet managed - canary style, green/blue) delivery into
							live service all with the ability to regress/recall at anytime if any unwanted side effects are observed.
						</p>
						<h3>Agile Delivery</h3>
						<p>
							Through less focus on contract, reuse and with a focus on function not component, less effort is spent designing microservices
							with good effort spent on Implementing microservices on the premise that 'anything can change'.
							This makes microservices more suited to an agile development lifecycle.
							
							<br/><br/>
							Yes, you could spend months decomposing your problem domain, designing and specifying all such functions, then coding, building and deploying
							such functions and then finally constructing business logic from the deployed functions. Just like SOA.
							Moreso, you should simply develop your microservices (functions) whilst developing business logic; there is no formal contract for the
							microservice.

							<br/><br/>
							Knowing only what you know at time, and doing only what you know at the time; this is agile delivery.
						</p>
						<h3>Monitoring</h3>
						<p>
							With tens/hundreds of microservices deployed, with runtime isolation (see above) across multiple business proceses
							you have a complex function runtime with independent runtime characteristics.
							
							Traditional tools to profiling and optimising those characteristics do not fit well when the services are distributed
							within a platform or worse still across different platforms.

							Without a good monitoring solution in place, you&apos;re assuming everything we be ok and when it is not, you'll be
							frantically or worse still, haphazardously, hacking away to identity and then fix the problem. You are likely to make
							the problem worse before it becomes better.

							<i>But what are the solutions? Still in infancy but some stop players already emerging:
								<ul>
									<li><a target="_blank" href="https://serverless.com/dashboard">serverless framework dashboard</a></li>
									<li><a target="_blank" href="https://zipkin.io/">Zipkin</a></li>
									<li><a target="_blank" href="https://opentracing.io/">OpenTracing</a></li>

									

									<li class="tbc"><a target="_blank" href="https://aws.amazon.com/xray/">AWS X-Ray</a> - proprietary to AWS of course</li>
									<li class="tbc"><a target="_blank" href="https://aws.amazon.com/xray/">AWS X-Ray</a> - proprietary to AWS of course</li>

									<li class="tbc"><a target="_blank" href="https://www.datadoghq.com/dg/apm/microservices">Datadog</a></li>
									<li class="tbc"><a target="_blank" href="https://www.appdynamics.com/app-iq-platform/microservices-iq/">AppDynamics</a></li>
								</ul>

							</i>
						</p>
					</div>
				</section>

				<section id="patterns" class="spotlights">
					<section>
						<div class="content">
							<div class="inner">
								<header class="major">
									<h2>Patterns</h2>
								</header>
								<p>Introduction to microservices patterns</p>
								<ul class="actions">
									<li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns" class="button" target="_blank">Microsoft Patterns</a></li>
									<li><a href="https://microservices.io/patterns/" class="button" target="_blank">Open Source Patterns</a> supported by <a href="https://konghq.com/" target="_blank">Kong</a></li>
								</ul>
							</div>
						</div>
					</section>
					<section>
						<div class="content">
							<div class="inner">
								<header class="major">
									<h3>Circuit Breaker</h3>
								</header>
								<p>Stuff on circuit-breaker pattern</p>
								<ul class="actions">
									<li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker" class="button" target="_blank">Learn more</a></li>
								</ul>
							</div>
						</div>
					</section>
					<section>
						<div class="content">
							<div class="inner">
								<header class="major">
									<h3>Backend for Frontends</h3>
								</header>
								<p>Stuff on backends for Frontends pattern</p>
								<ul class="actions">
									<li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/backends-for-frontends" class="button" target="_blank">Learn more</a></li>
									<li><a href="https://microservices.io/patterns/apigateway.html" class="button" target="_blank">Learn more from Open Source</a></li>
								</ul>
							</div>
						</div>
					</section>
					<section>
						<div class="content">
							<div class="inner">
								<header class="major">
									<h3>Priority Queue</h3>
								</header>
								<p>Stuff on prioirty queues pattern</p>
								<ul class="actions">
									<li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/priority-queue" class="button" target="_blank">Learn more from Microsoft</a></li>
								</ul>
							</div>
						</div>
					</section>
				</section>
			</div>

			<!-- Footer -->
			<footer id="footer">
				<div class="inner">
					<ul class="copyright">
						<li>&copy; WOZ<i>iTech</i> 2018</li><li>Design: <a href="https://html5up.net">HTML5 UP (Forty)</a></li>
					</ul>
				</div>
			</footer>
		</div>

		<!-- Scripts -->
		<script src="../assets/js/jquery.min.js"></script>
		<script src="../assets/js/jquery.scrolly.min.js"></script>
		<script src="../assets/js/jquery.scrollex.min.js"></script>
		<script src="../assets/js/skel.min.js"></script>
		<script src="../assets/js/util.js"></script>
		<!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
		<script src="../assets/js/main.js"></script>
	</body>
</html>